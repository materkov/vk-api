#vk-api

API для приложения VKOrders.

## Структура
Содержит реализацию бекенда на PHP. Для организации структуры кода я старался адаптировать
некоторые принципы DDD. 

Никаких сторонних composer-пакетов не используется. Из расширений PHP
нужен mbstring, bcmath и mysqli

Входной точкой является файл app.php. Запуск с встроенным сервером:
```
DB_HOST=127.0.0.1 DB_USER=root DB_PASS=root DB_PORT=3306 php -S localhost:8000 app.php
```
Конфигурация через переменные окружения (DB_HOST, DB_PORT, DB_USER, DB_PASS)

## Описание структуры
Модуль API представляет собой HTTP-ручку приложения (уровень интерфейсов). Файл 
`router.php` по URL и типу запроса определяет, какой хендлер вызвать.
Файл `middleware.php` содержит некоторые вспомогательные хелперы. Файл `api.php` 
преобразовывает входные параметры (в терминах HTTP, это URL, тип запроса, заголовки,
тело запроса) в аргументы вызова функции (из уровня приложения). Затем он преобразовывает
ответ этой функции в "термины" из HTTP: код ответа, тело ответа, заголовки.

Модуль APP отражает уровень представления, то есть место, где 
непосредственно реализована бизнес-логика.
Файл `orders.php` реализует методы работы с заказами, файл `users.php` - с пользователями.
Файл `errors.php` содержит коды ошибок, `app.php` - входная точка в уровень приложения.

Модуль store содержит стораджи (хранилища данных). Реализовано два стораджа:
persistent (на базе MySQL) и memory (мок-хранилище, хранит данные в опертивной памяти).
Memory storage нужен исключительно для написания тестов на уровень приложения. 
Persistent storage сделан на базе драйвера mysqli (PDO не использовал, так как
запрещено использовать ООП).
Сторадж реализует операции работы с базой данных: добавление, удаление, получение списка
и т.д.

Модуль `tests` содержит тесты.

В `tests/app` содержатся тесты уровня приложения (с использованием мок-стораджа).

В `tests/functional` содержится функциональный тест, последовательно прогоняющий 
все методы (начиная от регистрации и заканчивая выполнением заказа)

В `tests/store` содержится тест, проверящий что флоу подтверждения заказа (который включает
в себя несколько шагов), является идемпотентым.

В `tests/utils` содержатся тесты на вспомогательные функции.

Модуль `utils` содержит несколько вспомогательных функций.


## Обработка ошибок
Вопрос, над которым долго думал - как организовывать обработку ошибок, при 
условии что нельзя использовать ООП, а значит и исключения тоже.

Есть несколько подходов, без использования исключений.  В современных версиях PHP ошибки принято обрабатывать через исключения,
но так как их использовать нельзя, то я выбрал компромиссный стиль:

1) Если функция имеет много "вариантов завершения" (например, функция выполнить заказ) то возвращаемым
значением будет являться код ошибки. Код 0 означает ОК, ненулевой - значит что-то пошло не так.
Возврашаемые аргументы передаются через ссылочные переменные

2) Если вариантов завершения немного. Например: успех, заказ не найден, ошибка стораджа. Тогда используется 
такой подход: NULL означает объект не найден, FALSE - общая ошибка (General Error), иначе - заказ.
При таком подходе, для того чтобы получить детали ошибки, нужно вызывать дополнительно функцию (GetLastError),
и приходится использовать глобальную переменную для хранения "последней ошибки". Конечно, такой подход
не потокобезопасен, но в PHP же нет потоков :)

Если говорить в общем, то мне больше всего нравится подход, принятый в Go: последний возвращаемый 
аргумент имеет тип error. Так, информация об ошибке получается сразу 
(не нужно ничего дозапрашивать), и не используются глобальные переменные.
Использовать этот подход здесь я не стал, так как подумал что он будет выглядеть "чужеродно" в экосистеме PHP.


## Тесты
Запуск юнит-тестов:
```
php tests/app/orders_test.php
php tests/app/users_test.php

php tests/utils/tokens_test.php
```

Для функционального теста требуется, чтобы был запущен инстанс приложения по адресу localhost:8000.
Далее запуск тестов:
```
php tests/functional/functional_test.php
```

Есть отдельный тест, проверяющий что последовательность операций "выполнение заказа" является 
идемпотентной (см. ниже):
```
php tests/store/test_transactions.php
```

Тесты, проверябщие работу кеша:
```
php tests/store/test_orderscache.php
php tests/store/test_usercache.php
```

## Структура БД
Таблица order содержит заказы (id, название, описание, ID автора заказа, флаг выполненности, цена)

Таблица user содержит пользователей (id, юзернейм, bcrypt-хеш пароля, баланс, может ли создавать заказы, 
может ли выполнять заказы)

Таблица transaction используется для сохранения транзакций. 

Предполагается, что таблицы могут находится на разных БД. То есть, есть три сервиса: сервис пользователей,
сервис заказов, транзакционный сервис.

Операция выполнения заказа состоит из нескольких шагов.

Сначала идет работа транзакционного сервиса. Создание записи в transaction:
```
INSERT INTO vk.transaction (order_id, sum, finished, user_id, balance) 
        VALUES
        (
            $orderId, $orderSum, 0, $contractorId, 
            (
                SELECT old_balance
                FROM (
                    SELECT COALESCE(
                        (SELECT balance FROM vk.transaction WHERE user_id = $contractorId ORDER BY id DESC LIMIT 1),
                        0
                    ) AS old_balance
                ) AS old_balance
            ) + $orderSum
        );
```

После этого нужно обновить баланс пользователя (UPDATE ... в сервисе пользователей), 
записав туда баланс из транзакционного сервиса.
Затем пометить заказ как выполненный (UPDATE ... в сервисе заказов). 
После этого транзакция помечается как выполненная (UPDATE в транзакционном сервисе).

Флоу спроектирован так, что при фейле на любом из шагов, операцию можно безопасно
повторять заново (идемпотентность).

Для контроля целостности можно еще добавить какого-нибудь демона, который будет выбирать из транзакционного сервиса
незавершенные транзакции (finished=false) и будет пытаться "допровести" их.

Таким образом, система обладает свойством eventual consistency, т.е. в конечном счете система перейдет в согласованное
состояние. В некоторые моменты времени, она может возвращать несогласованные данные (например, транзакция уже есть,
но деньги на баланс не зачислены), но в конечном итоге состояние будет согласованным.

## Финансовая математика
Реализована через bcmath

## Авторизация
Для того чтобы не использовать обычные токены/сессии используется нечто похожее на JWT.
Пример токена:
```
eyJjYW5fY3JlYXRlX29yZGVyIjpmYWxzZSwiY2FuX2V4ZWN1dGVfb3JkZXIiOmZhbHNlLCJleHAiOjE1MTE2MzA0NDIsImlkIjoxLCJ1c2VybmFtZSI6InVzZXIxIn0.a811972f3b81f30c668cfe30b0b828bf9f6adc0a59d5e10e9d1e244f4b61ef86
```
Первая часть - payload, вторая - подпись (HMAC SHA256). Если расшифровать payload
получится следующее:
```
{"can_create_order":false,"can_execute_order":false,"exp":1511630442,"id":1,"username":"user1"}
```

Главный плюс - избавляемся от необходимости ходить в БД 
для проверки токенов. Главный минус - токен невозможно "отозвать".


## Кеширование
Кеширующий уровень сделан на базе Redis.
Кешируются юзеры (с инваоидацией при обновлении), кешируются заказы (
с инвалидацией при обновлении) и список заказов (все "списки" инвалидируются
при изменении любого заказа)

Ключи в редисе:
```
GET users:{ID}
GET orders:{id}
HGET orders_list {limit}:{after}
```
